<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MutableArithmetics</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MutableArithmetics</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MutableArithmetics.jl"><a class="docs-heading-anchor" href="#MutableArithmetics.jl">MutableArithmetics.jl</a><a id="MutableArithmetics.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MutableArithmetics.jl" title="Permalink"></a></h1><ul><li><a href="#MutableArithmetics.IsMutable"><code>MutableArithmetics.IsMutable</code></a></li><li><a href="#MutableArithmetics.IsNotMutable"><code>MutableArithmetics.IsNotMutable</code></a></li><li><a href="#MutableArithmetics.MutableTrait"><code>MutableArithmetics.MutableTrait</code></a></li><li><a href="#MutableArithmetics._broadcasted_type-Tuple{Base.Broadcast.BroadcastStyle, Base.HasShape, Type}"><code>MutableArithmetics._broadcasted_type</code></a></li><li><a href="#MutableArithmetics._rewrite"><code>MutableArithmetics._rewrite</code></a></li><li><a href="#MutableArithmetics._rewrite_generic-Tuple{Expr, Expr}"><code>MutableArithmetics._rewrite_generic</code></a></li><li><a href="#MutableArithmetics._rewrite_generic-Tuple{Expr, Any}"><code>MutableArithmetics._rewrite_generic</code></a></li><li><a href="#MutableArithmetics._rewrite_generic"><code>MutableArithmetics._rewrite_generic</code></a></li><li><a href="#MutableArithmetics._rewrite_generic-Tuple{Expr, Number}"><code>MutableArithmetics._rewrite_generic</code></a></li><li><a href="#MutableArithmetics._rewrite_generic_generator"><code>MutableArithmetics._rewrite_generic_generator</code></a></li><li><a href="#MutableArithmetics.add!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.add!!</code></a></li><li><a href="#MutableArithmetics.add_dot-Union{Tuple{N}, Tuple{Any, Any, Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.add_dot</code></a></li><li><a href="#MutableArithmetics.add_mul"><code>MutableArithmetics.add_mul</code></a></li><li><a href="#MutableArithmetics.add_mul!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.add_mul!!</code></a></li><li><a href="#MutableArithmetics.add_mul_buf!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.add_mul_buf!!</code></a></li><li><a href="#MutableArithmetics.add_mul_buf_to!!-Union{Tuple{N}, Tuple{Any, Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.add_mul_buf_to!!</code></a></li><li><a href="#MutableArithmetics.add_mul_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.add_mul_to!!</code></a></li><li><a href="#MutableArithmetics.add_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.add_to!!</code></a></li><li><a href="#MutableArithmetics.broadcast!"><code>MutableArithmetics.broadcast!</code></a></li><li><a href="#MutableArithmetics.broadcast!!-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.broadcast!!</code></a></li><li><a href="#MutableArithmetics.broadcast_mutability-Union{Tuple{N}, Tuple{Type, Any, Vararg{Type, N}}} where N"><code>MutableArithmetics.broadcast_mutability</code></a></li><li><a href="#MutableArithmetics.buffered_operate!"><code>MutableArithmetics.buffered_operate!</code></a></li><li><a href="#MutableArithmetics.buffered_operate!!-Union{Tuple{N}, Tuple{F}, Tuple{Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.buffered_operate!!</code></a></li><li><a href="#MutableArithmetics.buffered_operate_to!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.buffered_operate_to!</code></a></li><li><a href="#MutableArithmetics.buffered_operate_to!!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.buffered_operate_to!!</code></a></li><li><a href="#MutableArithmetics.copy_if_mutable-Tuple{Any}"><code>MutableArithmetics.copy_if_mutable</code></a></li><li><a href="#MutableArithmetics.div!!-Tuple{Any, Any}"><code>MutableArithmetics.div!!</code></a></li><li><a href="#MutableArithmetics.div_to!!-Tuple{Any, Any, Any}"><code>MutableArithmetics.div_to!!</code></a></li><li><a href="#MutableArithmetics.gcd!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.gcd!!</code></a></li><li><a href="#MutableArithmetics.gcd_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.gcd_to!!</code></a></li><li><a href="#MutableArithmetics.isequal_canonical-Tuple{Any, Any}"><code>MutableArithmetics.isequal_canonical</code></a></li><li><a href="#MutableArithmetics.iszero!!-Tuple{Any}"><code>MutableArithmetics.iszero!!</code></a></li><li><a href="#MutableArithmetics.lcm!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.lcm!!</code></a></li><li><a href="#MutableArithmetics.lcm_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.lcm_to!!</code></a></li><li><a href="#MutableArithmetics.mul-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.mul</code></a></li><li><a href="#MutableArithmetics.mul!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.mul!!</code></a></li><li><a href="#MutableArithmetics.mul_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.mul_to!!</code></a></li><li><a href="#MutableArithmetics.mutability-Union{Tuple{N}, Tuple{Type, Any, Vararg{Type, N}}} where N"><code>MutableArithmetics.mutability</code></a></li><li><a href="#MutableArithmetics.mutable_copy"><code>MutableArithmetics.mutable_copy</code></a></li><li><a href="#MutableArithmetics.one!!-Tuple{Any}"><code>MutableArithmetics.one!!</code></a></li><li><a href="#MutableArithmetics.operate"><code>MutableArithmetics.operate</code></a></li><li><a href="#MutableArithmetics.operate!-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.operate!</code></a></li><li><a href="#MutableArithmetics.operate!!-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.operate!!</code></a></li><li><a href="#MutableArithmetics.operate_to!-Union{Tuple{N}, Tuple{F}, Tuple{Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.operate_to!</code></a></li><li><a href="#MutableArithmetics.operate_to!!-Union{Tuple{N}, Tuple{F}, Tuple{Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.operate_to!!</code></a></li><li><a href="#MutableArithmetics.promote_operation-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Type, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.promote_operation</code></a></li><li><a href="#MutableArithmetics.rewrite-Tuple{Any}"><code>MutableArithmetics.rewrite</code></a></li><li><a href="#MutableArithmetics.rewrite_and_return-Tuple{Any}"><code>MutableArithmetics.rewrite_and_return</code></a></li><li><a href="#MutableArithmetics.rewrite_generator-Tuple{Any, Any}"><code>MutableArithmetics.rewrite_generator</code></a></li><li><a href="#MutableArithmetics.sub!!-Tuple{Any, Any}"><code>MutableArithmetics.sub!!</code></a></li><li><a href="#MutableArithmetics.sub_mul"><code>MutableArithmetics.sub_mul</code></a></li><li><a href="#MutableArithmetics.sub_mul!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.sub_mul!!</code></a></li><li><a href="#MutableArithmetics.sub_mul_buf!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.sub_mul_buf!!</code></a></li><li><a href="#MutableArithmetics.sub_mul_buf_to!!-Union{Tuple{N}, Tuple{Any, Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.sub_mul_buf_to!!</code></a></li><li><a href="#MutableArithmetics.sub_mul_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.sub_mul_to!!</code></a></li><li><a href="#MutableArithmetics.sub_to!!-Tuple{Any, Any, Any}"><code>MutableArithmetics.sub_to!!</code></a></li><li><a href="#MutableArithmetics.zero!!-Tuple{Any}"><code>MutableArithmetics.zero!!</code></a></li><li><a href="#MutableArithmetics.@rewrite-Tuple"><code>MutableArithmetics.@rewrite</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.IsMutable" href="#MutableArithmetics.IsMutable"><code>MutableArithmetics.IsMutable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsMutable &lt;: MutableTrait end</code></pre><p>When this is returned by <a href="#MutableArithmetics.mutability-Union{Tuple{N}, Tuple{Type, Any, Vararg{Type, N}}} where N"><code>mutability</code></a>, it means that object of the given type can always be mutated to equal the result of the operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL281-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.IsNotMutable" href="#MutableArithmetics.IsNotMutable"><code>MutableArithmetics.IsNotMutable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsNotMutable &lt;: MutableTrait end</code></pre><p>When this is returned by <a href="#MutableArithmetics.mutability-Union{Tuple{N}, Tuple{Type, Any, Vararg{Type, N}}} where N"><code>mutability</code></a>, it means that object of the given type cannot be mutated to equal the result of the operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL289-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.MutableTrait" href="#MutableArithmetics.MutableTrait"><code>MutableArithmetics.MutableTrait</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type MutableTrait end</code></pre><p>Abstract type for <a href="#MutableArithmetics.IsMutable"><code>IsMutable</code></a> and <a href="#MutableArithmetics.IsNotMutable"><code>IsNotMutable</code></a> that are returned by <a href="#MutableArithmetics.mutability-Union{Tuple{N}, Tuple{Type, Any, Vararg{Type, N}}} where N"><code>mutability</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL273-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics._broadcasted_type-Tuple{Base.Broadcast.BroadcastStyle, Base.HasShape, Type}" href="#MutableArithmetics._broadcasted_type-Tuple{Base.Broadcast.BroadcastStyle, Base.HasShape, Type}"><code>MutableArithmetics._broadcasted_type</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This method is a generic fallback for array types that are not <code>DefaultArrayStyle</code>. Because we can&#39;t tell the container from a generic broadcast style, we fallback to <code>Any</code>, which is always a valid super type (just not a helpful one).</p><p>In MutableArithmetics, <code>_broadcasted_type</code> appears only in <code>promote_broadcast</code>, which itself appears only in <code>broadcast_mutability</code>, and so types hitting this method will fallback to the <code>IsNotMutable()</code> branch, which is the expected outcome.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/broadcast.jl#LL26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics._rewrite" href="#MutableArithmetics._rewrite"><code>MutableArithmetics._rewrite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_rewrite(
    vectorized::Bool,
    minus::Bool,
    inner_factor,
    current_sum::Union{Symbol, Nothing},
    left_factors::Vector,
    right_factors::Vector,
    new_var::Symbol = gensym(),
)</code></pre><p>Return <code>new_var, code</code> such that <code>code</code> is equivalent to</p><pre><code class="language-julia hljs">new_var = prod(left_factors) * inner_factor * prod(reverse(right_factors))</code></pre><p>If <code>current_sum</code> is <code>nothing</code>, and is</p><pre><code class="language-julia hljs">new_var = current_sum op prod(left_factors) * inner_factor * prod(reverse(right_factors))</code></pre><p>otherwise where <code>op</code> is <code>+</code> if <code>!vectorized &amp; !minus</code>, <code>.+</code> if <code>vectorized &amp; !minus</code>, <code>-</code> if <code>!vectorized &amp; minus</code> and <code>.-</code> if <code>vectorized &amp; minus</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/rewrite.jl#LL468-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics._rewrite_generic" href="#MutableArithmetics._rewrite_generic"><code>MutableArithmetics._rewrite_generic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_rewrite_generic(stack::Expr, expr::T)::Tuple{Any,Bool}</code></pre><p>This method is the heart of the rewrite logic. It converts <code>expr</code> into a mutable equivalent, places any intermediate calculations onto <code>stack</code>, and returns a tuple containing the return value–-which is either <code>expr</code> or a <code>gensym</code>ed variable equivalent to <code>expr</code>–-and a boolean flag that indicates whether the return value can be mutated by future callers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/rewrite_generic.jl#LL11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics._rewrite_generic-Tuple{Expr, Any}" href="#MutableArithmetics._rewrite_generic-Tuple{Expr, Any}"><code>MutableArithmetics._rewrite_generic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_rewrite_generic(::Expr, x)</code></pre><p>A generic fallback. Given a type <code>x</code> we return it without mutation. In addition, this type should not be mutated by future callers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/rewrite_generic.jl#LL22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics._rewrite_generic-Tuple{Expr, Expr}" href="#MutableArithmetics._rewrite_generic-Tuple{Expr, Expr}"><code>MutableArithmetics._rewrite_generic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_rewrite_generic(stack::Expr, expr::Expr)</code></pre><p>This method is the heart of the rewrite logic. It converts <code>expr</code> into a mutable equivalent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/rewrite_generic.jl#LL76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics._rewrite_generic-Tuple{Expr, Number}" href="#MutableArithmetics._rewrite_generic-Tuple{Expr, Number}"><code>MutableArithmetics._rewrite_generic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_rewrite_generic(::Expr, x::Number)</code></pre><p>If <code>x</code> is a <code>Number</code> at macro expansion time, it <em>must</em> be a constant literal. We return <code>x</code> without mutation, but we return <code>true</code> because other callers may mutate the value without fear. Put aother way, they don&#39;t need to wrap the value in <code>copy_if_mutable(x)</code> before using it as the first argument to <code>operate!!</code>.</p><p>This most commonly happens in situations like <code>x^2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/rewrite_generic.jl#LL30-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics._rewrite_generic_generator" href="#MutableArithmetics._rewrite_generic_generator"><code>MutableArithmetics._rewrite_generic_generator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_rewrite_generic_generator(stack::Expr, op::Symbol, expr::Expr)</code></pre><p>Special handling for generator expressions.</p><p><code>op</code> is <code>:+</code> and <code>expr</code> is a <code>:generator</code> or <code>:flatten</code> expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/rewrite_generic.jl#LL288-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.add!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N" href="#MutableArithmetics.add!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.add!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add!!(a, b, ...)</code></pre><p>Return the sum of <code>a</code>, <code>b</code>, ..., possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.add_dot-Union{Tuple{N}, Tuple{Any, Any, Any, Vararg{Any, N}}} where N" href="#MutableArithmetics.add_dot-Union{Tuple{N}, Tuple{Any, Any, Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.add_dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_dot(a, args...)</code></pre><p>Return <code>a + dot(args...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/MutableArithmetics.jl#LL41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.add_mul" href="#MutableArithmetics.add_mul"><code>MutableArithmetics.add_mul</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_mul(a, args...)</code></pre><p>Return <code>a + *(args...)</code>. Note that <code>add_mul(a, b, c) = muladd(b, c, a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/MutableArithmetics.jl#LL20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.add_mul!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N" href="#MutableArithmetics.add_mul!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.add_mul!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_mul!!(args...)</code></pre><p>Return <code>add_mul(args...)</code>, possibly modifying <code>args[1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.add_mul_buf!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N" href="#MutableArithmetics.add_mul_buf!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.add_mul_buf!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_mul_buf!!(buffer, args...)</code></pre><p>Return <code>add_mul(args...)</code>, possibly modifying <code>args[1]</code> and <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.add_mul_buf_to!!-Union{Tuple{N}, Tuple{Any, Any, Vararg{Any, N}}} where N" href="#MutableArithmetics.add_mul_buf_to!!-Union{Tuple{N}, Tuple{Any, Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.add_mul_buf_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_mul_buf_to!!(buffer, output, args...)</code></pre><p>Return <code>add_mul(args...)</code>, possibly modifying <code>output</code> and <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.add_mul_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N" href="#MutableArithmetics.add_mul_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.add_mul_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_mul_to!!(output, args...)</code></pre><p>Return <code>add_mul(args...)</code>, possibly modifying <code>output</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.add_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N" href="#MutableArithmetics.add_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.add_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_to!!(a, b, c)</code></pre><p>Return the sum of <code>b</code> and <code>c</code>, possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.broadcast!" href="#MutableArithmetics.broadcast!"><code>MutableArithmetics.broadcast!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">broadcast!(op::Function, args...)</code></pre><p>Modify the value of <code>args[1]</code> to be equal to the value of <code>broadcast(op, args...)</code>.</p><p>This method can only be called if <code>mutability(args[1], op, args...)</code> returns <a href="#MutableArithmetics.IsMutable"><code>IsMutable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/broadcast.jl#LL147-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.broadcast!!-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Any, N}}} where {F&lt;:Function, N}" href="#MutableArithmetics.broadcast!!-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.broadcast!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">broadcast!!(op::Function, args...)</code></pre><p>Returns the value of <code>broadcast(op, args...)</code>, possibly modifying <code>args[1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/broadcast.jl#LL190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.broadcast_mutability-Union{Tuple{N}, Tuple{Type, Any, Vararg{Type, N}}} where N" href="#MutableArithmetics.broadcast_mutability-Union{Tuple{N}, Tuple{Type, Any, Vararg{Type, N}}} where N"><code>MutableArithmetics.broadcast_mutability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">broadcast_mutability(T::Type, ::typeof(op), args::Type...)::MutableTrait</code></pre><p>Return <code>IsMutable</code> to indicate an object of type <code>T</code> can be modified to be equal to <code>broadcast(op, args...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/broadcast.jl#LL87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.buffered_operate!" href="#MutableArithmetics.buffered_operate!"><code>MutableArithmetics.buffered_operate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">buffered_operate!(buffer, op::Function, args...)</code></pre><p>Modify the value of <code>args[1]</code> to be equal to the value of <code>op(args...)</code>, possibly modifying <code>buffer</code>. Can only be called if <code>mutability(args[1], op, args...)</code> returns <a href="#MutableArithmetics.IsMutable"><code>IsMutable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL592-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.buffered_operate!!-Union{Tuple{N}, Tuple{F}, Tuple{Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}" href="#MutableArithmetics.buffered_operate!!-Union{Tuple{N}, Tuple{F}, Tuple{Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.buffered_operate!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">buffered_operate!!(buffer, op::Function, args...)</code></pre><p>Returns the value of <code>op(args...)</code>, possibly modifying <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL706-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.buffered_operate_to!!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}" href="#MutableArithmetics.buffered_operate_to!!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.buffered_operate_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">buffered_operate_to!(buffer, output, op::Function, args...)</code></pre><p>Returns the value of <code>op(args...)</code>, possibly modifying <code>buffer</code> and <code>output</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL666-L670">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.buffered_operate_to!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}" href="#MutableArithmetics.buffered_operate_to!-Union{Tuple{N}, Tuple{F}, Tuple{Any, Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.buffered_operate_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">buffered_operate_to!(buffer, output, op::Function, args...)</code></pre><p>Modify the value of <code>output</code> to be equal to the value of <code>op(args...)</code>, possibly modifying <code>buffer</code>. Can only be called if <code>mutability(output, op, args...)</code> returns <a href="#MutableArithmetics.IsMutable"><code>IsMutable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL528-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.copy_if_mutable-Tuple{Any}" href="#MutableArithmetics.copy_if_mutable-Tuple{Any}"><code>MutableArithmetics.copy_if_mutable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy_if_mutable(x)</code></pre><p>Return a copy of <code>x</code> that can be mutated with MultableArithmetics&#39;s API without altering <code>x</code>. If <code>mutability(x)</code> is <code>IsNotMutable</code> then <code>x</code> is returned as none of <code>x</code> can be mutated. Otherwise, it redirects to <a href="#MutableArithmetics.mutable_copy"><code>mutable_copy</code></a>. Mutable types should not implement a method for this function but should implement a method for <a href="#MutableArithmetics.mutable_copy"><code>mutable_copy</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL369-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.div!!-Tuple{Any, Any}" href="#MutableArithmetics.div!!-Tuple{Any, Any}"><code>MutableArithmetics.div!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div!!(a, b)</code></pre><p>Return <code>div(a, b)</code> possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.div_to!!-Tuple{Any, Any, Any}" href="#MutableArithmetics.div_to!!-Tuple{Any, Any, Any}"><code>MutableArithmetics.div_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_to!!(output, a, b)</code></pre><p>Return <code>div(a, b)</code> possibly modifying <code>output</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.gcd!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N" href="#MutableArithmetics.gcd!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.gcd!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gcd!!(a, b, ...)</code></pre><p>Return the <code>gcd</code> of <code>a</code>, <code>b</code>, ..., possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.gcd_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N" href="#MutableArithmetics.gcd_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.gcd_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gcd_to!!(a, b, c, ...)</code></pre><p>Return the <code>gcd</code> of <code>b</code>, <code>c</code>, ..., possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.isequal_canonical-Tuple{Any, Any}" href="#MutableArithmetics.isequal_canonical-Tuple{Any, Any}"><code>MutableArithmetics.isequal_canonical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isequal_canonical(a, b)</code></pre><p>Return whether <code>a</code> and <code>b</code> represent a same object, even if their representations differ.</p><p><strong>Examples</strong></p><p>The terms in two MathOptInterface affine functions may not match but once the duplicates are merged, the zero terms are removed and the terms are sorted in ascending order of variable indices (i.e. their canonical representation), the equality of the representation is equivalent to the equality of the objects begin represented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/MutableArithmetics.jl#LL118-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.iszero!!-Tuple{Any}" href="#MutableArithmetics.iszero!!-Tuple{Any}"><code>MutableArithmetics.iszero!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iszero!!(x)</code></pre><p>Return a <code>Bool</code> indicating whether <code>x</code> is zero, possibly modifying <code>x</code>.</p><p><strong>Examples</strong></p><p>In MathOptInterface, a <code>ScalarAffineFunction</code> may contain duplicate terms. In <code>Base.iszero</code>, duplicate terms need to be merged but the function is left with duplicates as it cannot be modified. If <code>iszero!!</code> is called instead, the function will be canonicalized in addition for checking whether it is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/MutableArithmetics.jl#LL56-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.lcm!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N" href="#MutableArithmetics.lcm!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.lcm!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lcm!!(a, b, ...)</code></pre><p>Return the <code>lcm</code> of <code>a</code>, <code>b</code>, ..., possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.lcm_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N" href="#MutableArithmetics.lcm_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.lcm_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lcm_to!!(a, b, c, ...)</code></pre><p>Return the <code>lcm</code> of <code>b</code>, <code>c</code>, ..., possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.mul!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N" href="#MutableArithmetics.mul!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.mul!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul!!(a, b, ...)</code></pre><p>Return the product of <code>a</code>, <code>b</code>, ..., possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.mul-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N" href="#MutableArithmetics.mul-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.mul</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(a, b, ...)</code></pre><p>Shortcut for <code>operate(*, a, b, ...)</code>, see <a href="#MutableArithmetics.operate"><code>operate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.mul_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N" href="#MutableArithmetics.mul_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.mul_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul_to!!(a, b, c, ...)</code></pre><p>Return the product of <code>b</code>, <code>c</code>, ..., possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.mutability-Union{Tuple{N}, Tuple{Type, Any, Vararg{Type, N}}} where N" href="#MutableArithmetics.mutability-Union{Tuple{N}, Tuple{Type, Any, Vararg{Type, N}}} where N"><code>MutableArithmetics.mutability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mutability(T::Type, ::typeof(op), args::Type...)::MutableTrait</code></pre><p>Return either <a href="#MutableArithmetics.IsMutable"><code>IsMutable</code></a> to indicate an object of type <code>T</code> can be modified to be equal to <code>op(args...)</code> or <a href="#MutableArithmetics.IsNotMutable"><code>IsNotMutable</code></a> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL297-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.mutable_copy" href="#MutableArithmetics.mutable_copy"><code>MutableArithmetics.mutable_copy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mutable_copy(x)</code></pre><p>Return a copy of <code>x</code> that can be mutated with MultableArithmetics&#39;s API without altering <code>x</code>.</p><p><strong>Examples</strong></p><p>The copy of a JuMP affine expression does not copy the underlying model as it cannot be modified though the MultableArithmetics&#39;s API, however, it calls <a href="#MutableArithmetics.copy_if_mutable-Tuple{Any}"><code>copy_if_mutable</code></a> on the coefficients and on the constant as they could be mutated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL348-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.one!!-Tuple{Any}" href="#MutableArithmetics.one!!-Tuple{Any}"><code>MutableArithmetics.one!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">one!!(a)</code></pre><p>Return <code>one(a)</code>, possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.operate" href="#MutableArithmetics.operate"><code>MutableArithmetics.operate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">operate(op::Function, args...)</code></pre><p>Return an object equal to the result of <code>op(args...)</code> that can be mutated through the MultableArithmetics API without affecting the arguments.</p><p>By default:</p><ul><li><code>operate(+, x)</code> and <code>operate(+, x)</code> redirect to <code>copy_if_mutable(x)</code> so a mutable type <code>T</code> can return the same instance from unary operators <code>+(x::T) = x</code> and <code>*(x::T) = x</code>.</li><li><code>operate(+, args...)</code> (resp. <code>operate(-, args...)</code> and <code>operate(*, args...)</code>) redirect to <code>+(args...)</code> (resp. <code>-(args...)</code> and <code>*(args...)</code>) if <code>length(args)</code> is at least 2 (or the operation is <code>-</code>).</li></ul><p>Note that when <code>op</code> is a <code>Base</code> function whose implementation can be improved for mutable arguments, <code>operate(op, args...)</code> may have an implementation in this package relying on the MutableArithmetics API instead of redirecting to <code>op(args...)</code>. This is the case for instance:</p><ul><li>for <code>Base.sum</code>,</li><li>for <code>LinearAlgebra.dot</code> and</li><li>for matrix-matrix product and matrix-vector product.</li></ul><p>Therefore, for mutable arguments, there may be a performance advantage to call <code>operate(op, args...)</code> instead of <code>op(args...)</code>.</p><p><strong>Example</strong></p><p>If for a mutable type <code>T</code>, the following is defined:</p><pre><code class="language-julia hljs">function Base.:*(a::Bool, x::T)
    return a ? x : zero(T)
end</code></pre><p>then <code>operate(*, a, x)</code> will return the instance <code>x</code> whose modification will affect the argument of <code>operate</code>. Therefore, the following method need to be implemented</p><pre><code class="language-julia hljs">function MA.operate(::typeof(*), a::Bool, x::T)
    return a ? MA.mutable_copy(x) : zero(T)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL174-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.operate!!-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Any, N}}} where {F&lt;:Function, N}" href="#MutableArithmetics.operate!!-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.operate!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">operate!!(op::Function, args...)</code></pre><p>Returns the value of <code>op(args...)</code>, possibly modifying <code>args[1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL641-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.operate!-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Any, N}}} where {F&lt;:Function, N}" href="#MutableArithmetics.operate!-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.operate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">operate!(op::Function, args...)</code></pre><p>Modify the value of <code>args[1]</code> to be equal to the value of <code>op(args...)</code>. Can only be called if <code>mutability(args[1], op, args...)</code> returns <a href="#MutableArithmetics.IsMutable"><code>IsMutable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL455-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.operate_to!!-Union{Tuple{N}, Tuple{F}, Tuple{Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}" href="#MutableArithmetics.operate_to!!-Union{Tuple{N}, Tuple{F}, Tuple{Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.operate_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">operate_to!(output, op::Function, args...)</code></pre><p>Returns the value of <code>op(args...)</code>, possibly modifying <code>output</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL609-L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.operate_to!-Union{Tuple{N}, Tuple{F}, Tuple{Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}" href="#MutableArithmetics.operate_to!-Union{Tuple{N}, Tuple{F}, Tuple{Any, F, Vararg{Any, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.operate_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">operate_to!(output, op::Function, args...)</code></pre><p>Modify the value of <code>output</code> to be equal to the value of <code>op(args...)</code>. Can only be called if <code>mutability(output, op, args...)</code> returns <a href="#MutableArithmetics.IsMutable"><code>IsMutable</code></a>.</p><p>If <code>output === args[i]</code> for some <code>i</code>, this function may throw an error. Use <code>operate!!</code> or <code>operate!</code> instead.</p><p>For example, in DynamicPolynomials, <code>operate_to!(p, +, p, q)</code> throws an error because otherwise, the algorithm would fill <code>p</code> while iterating over the terms of <code>p</code> and <code>q</code> hence it will never terminate. On the other hand <code>operate!(+, p, q)</code> uses a different algorithm that efficiently inserts the terms of <code>q</code> in the sorted list of terms of <code>p</code> with minimal displacement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL406-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.promote_operation-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Type, N}}} where {F&lt;:Function, N}" href="#MutableArithmetics.promote_operation-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Type, N}}} where {F&lt;:Function, N}"><code>MutableArithmetics.promote_operation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote_operation(op::Function, ArgsTypes::Type...)</code></pre><p>Returns the type returned to the call <code>operate(op, args...)</code> where the types of the arguments <code>args</code> are <code>ArgsTypes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/interface.jl#LL137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.rewrite-Tuple{Any}" href="#MutableArithmetics.rewrite-Tuple{Any}"><code>MutableArithmetics.rewrite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite(
    expr;
    move_factors_into_sums::Bool = true,
    return_is_mutable::Bool = false,
) -&gt; Tuple{Symbol,Expr[,Bool]}</code></pre><p>Rewrites the expression <code>expr</code> to use mutable arithmetics.</p><p>Returns <code>(variable, code)</code> comprised of a <code>gensym</code>&#39;d variable equivalent to <code>expr</code> and the code necessary to create the variable.</p><p><strong><code>move_factors_into_sums</code></strong></p><p>If <code>move_factors_into_sums = true</code>, some terms are rewritten based on the assumption that summations produce a linear function.</p><p>For example, if <code>move_factors_into_sums = true</code>, then <code>y * sum(x[i] for i in 1:2)</code> is rewritten to:</p><pre><code class="language-julia hljs">variable = MA.Zero()
for i in 1:2
    variable = MA.operate!!(MA.add_mul, result, y, x[i])
end</code></pre><p>If <code>move_factors_into_sums = false</code>, it is rewritten to:</p><pre><code class="language-julia hljs">term = MA.Zero()
for i in 1:2
    term = MA.operate!!(MA.add_mul, term, x[i])
end
variable = MA.operate!!(*, y, term)</code></pre><p>The latter can produce an additional allocation if there is an efficient fallback for <code>add_mul</code> and not for <code>*(y, term)</code>.</p><p><strong><code>return_is_mutable</code></strong></p><p>If <code>return_is_mutable = true</code>, this function returns three arguments. The third is a <code>Bool</code> indicating if the returned expression can be safely mutated without changing the user&#39;s original expression.</p><p><code>return_is_mutable</code> cannot be <code>true</code> if <code>move_factors_into_sums = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/rewrite.jl#LL291-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.rewrite_and_return-Tuple{Any}" href="#MutableArithmetics.rewrite_and_return-Tuple{Any}"><code>MutableArithmetics.rewrite_and_return</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite_and_return(
    expr;
    move_factors_into_sums::Bool = true,
    return_is_mutable::Bool = false,
) -&gt; Expr</code></pre><p>Rewrite the expression <code>expr</code> using mutable arithmetics and return an expression in which the last statement is equivalent to <code>expr</code>.</p><p>See <a href="#MutableArithmetics.rewrite-Tuple{Any}"><code>rewrite</code></a> for an explanation of the keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/rewrite.jl#LL347-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.rewrite_generator-Tuple{Any, Any}" href="#MutableArithmetics.rewrite_generator-Tuple{Any, Any}"><code>MutableArithmetics.rewrite_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite_generator(expr::Expr, inner::Function)</code></pre><p>Rewrites the generator statements <code>expr</code> and returns a properly nested for loop with nested filters as specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MutableArithmetics

julia&gt; MutableArithmetics.rewrite_generator(:(i for i in 1:2 if isodd(i)), i -&gt; :($i + 1))
:(for $(Expr(:escape, :(i = 1:2)))
      if $(Expr(:escape, :(isodd(i))))
          i + 1
      end
  end)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/rewrite.jl#LL151-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.sub!!-Tuple{Any, Any}" href="#MutableArithmetics.sub!!-Tuple{Any, Any}"><code>MutableArithmetics.sub!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sub!!(a, b)</code></pre><p>Return <code>a - b</code>, possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.sub_mul" href="#MutableArithmetics.sub_mul"><code>MutableArithmetics.sub_mul</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sub_mul(a, args...)</code></pre><p>Return <code>a - *(args...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/MutableArithmetics.jl#LL32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.sub_mul!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N" href="#MutableArithmetics.sub_mul!!-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>MutableArithmetics.sub_mul!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sub_mul!!(args...)</code></pre><p>Return <code>sub_mul(args...)</code>, possibly modifying <code>args[1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.sub_mul_buf!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N" href="#MutableArithmetics.sub_mul_buf!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.sub_mul_buf!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sub_mul_buf!!(buffer, args...)</code></pre><p>Return <code>sub_mul(args...)</code>, possibly modifying <code>args[1]</code> and <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.sub_mul_buf_to!!-Union{Tuple{N}, Tuple{Any, Any, Vararg{Any, N}}} where N" href="#MutableArithmetics.sub_mul_buf_to!!-Union{Tuple{N}, Tuple{Any, Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.sub_mul_buf_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sub_mul_buf_to!!(buffer, output, args...)</code></pre><p>Return <code>sub_mul(args...)</code>, possibly modifying <code>output</code> and <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.sub_mul_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N" href="#MutableArithmetics.sub_mul_to!!-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N"><code>MutableArithmetics.sub_mul_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sub_mul_to!!(output, args...)</code></pre><p>Return <code>sub_mul(args...)</code>, possibly modifying <code>output</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.sub_to!!-Tuple{Any, Any, Any}" href="#MutableArithmetics.sub_to!!-Tuple{Any, Any, Any}"><code>MutableArithmetics.sub_to!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sub_to!!(output, a, b)</code></pre><p>Return the <code>a - b</code>, possibly modifying <code>output</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.zero!!-Tuple{Any}" href="#MutableArithmetics.zero!!-Tuple{Any}"><code>MutableArithmetics.zero!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero!!(a)</code></pre><p>Return <code>zero(a)</code>, possibly modifying <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/shortcuts.jl#LL176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MutableArithmetics.@rewrite-Tuple" href="#MutableArithmetics.@rewrite-Tuple"><code>MutableArithmetics.@rewrite</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rewrite(expr, move_factors_into_sums = true)</code></pre><p>Return the value of <code>expr</code>, exploiting the mutability of the temporary expressions created for the computation of the result.</p><p>If you have an <code>Expr</code> as input, use <a href="#MutableArithmetics.rewrite_and_return-Tuple{Any}"><code>rewrite_and_return</code></a> instead.</p><p>See <a href="#MutableArithmetics.rewrite-Tuple{Any}"><code>rewrite</code></a> for an explanation of the keyword argument.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Passing <code>move_factors_into_sums</code> after a <code>;</code> is not supported. Use a <code>,</code> instead.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MutableArithmetics.jl/blob/2bffb5faab6b550ebf1365ae536287d8e8c3f682/src/rewrite.jl#LL7-L20">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 17 September 2025 10:44">Wednesday 17 September 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
